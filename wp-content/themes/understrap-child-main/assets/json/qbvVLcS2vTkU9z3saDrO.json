{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"gradient","speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;const vec3 uColors[1] = vec3[]( vec3(0.015686, 0.152941, 0.243137) );uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return uColors[0]; }void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.51) + mix(vec2(0), (uMousePos-0.5), 0.00); uv -= pos; uv /= (0.50*2.); uv = rotate(uv, (0.00 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"min":992,"max":null,"name":"Desktop","props":{"trackMouse":0,"lineHeight":83,"translateX":-73.5,"height":83,"fontSize":83,"letterSpacing":-4,"mouseMomentum":0,"textContent":"JUST LAUNCHED","translateY":232,"rotation":0,"width":693}},{"min":576,"props":{"translateY":227.5,"translateX":-73.5,"height":83,"lineHeight":83},"name":"Tablet","max":991},{"props":{"translateX":-72.5,"trackMouse":0,"mouseMomentum":0,"rotation":0,"translateY":227.5},"min":0,"name":"Mobile","max":575}],"visible":true,"locked":false,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"text","justCreated":false,"effects":["e02c46e5-ff7e-471a-b3c7-98b82c56d157"],"fill":["#EDF0FF"],"fontSize":83,"fontCSS":{"src":"https://assets.unicorn.studio/fonts/google_fonts/8vIS7w4qzmVxsWxjBZRjr0FKM_04uT6kR47NCV5Z.ttf","family":"Syne"},"lineHeight":83,"letterSpacing":-4,"fontFamily":"Syne","fontStyle":"regular","fontWeight":"400","textAlign":"center","textContent":"JUST LAUNCHED","gradientAngle":0,"gradientType":"linear","coords":[[0,0],[693,0],[693,83],[0,83]],"rotation":0,"translateX":-73.5,"translateY":232,"width":693,"height":83,"isSafari":false,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg; uniform float uTrackMouse;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), uTrackMouse);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[{"name":"Desktop","max":null,"min":992,"props":{"amount":0.31,"repeatCount":10,"speed":-0.05,"angle":0.0567}},{"props":{"repeatCount":10},"max":991,"name":"Tablet","min":576},{"props":{"repeatCount":11},"max":575,"min":0,"name":"Mobile"}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"replicate","repeatCount":10,"speed":-0.05,"parentLayer":"e02c46e5-ff7e-471a-b3c7-98b82c56d157","animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"type":"appear","id":"10c7b4a3-8b75-47a1-8c09-f6b6397b931b","prop":"repeatCount","transition":{"ease":"easeInOutExpo","delay":1500,"duration":1000},"complete":false,"progress":0,"initialStateSet":false,"value":1,"uniformData":{"type":"1f","name":"uRepeatCount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform float uRepeatCount;uniform vec2 uResolution;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float rotation = (0.06 * 2. * 3.141592653); float aspectRatio = uResolution.x/uResolution.y; vec2 aberrated = vec2(0); vec4 col = vec4(0); float repeatSpacing = 0.31 * 0.35 * mix(1., aspectRatio, 0.5); float time = (uTime * 0.025) / (repeatSpacing + 0.001);for(float i = 0.; i < uRepeatCount; i++){ float offset = repeatSpacing * (i - uRepeatCount/2. + fract(time)); aberrated = vec2(offset * sin(rotation), offset * cos(rotation)); col += texture(uTexture, uv + aberrated) * (1. - col.a); } fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"repeatCount":{"name":"uRepeatCount","type":"1f","value":16}}}},{"breakpoints":[{"max":null,"name":"Desktop","min":992,"props":{"axisTilt":0,"trackMouse":0.13,"fitToCanvas":1,"mouseMomentum":0.42}},{"props":{"fitToCanvas":1,"mouseMomentum":0},"name":"Tablet","max":991,"min":576},{"name":"Mobile","max":575,"props":{"mouseMomentum":0,"fitToCanvas":0},"min":0}],"visible":true,"locked":true,"aspectRatio":1,"layerName":"","isElement":true,"opacity":1,"displace":0,"trackMouse":0.13,"mouseMomentum":0.42,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"effects":["f91ec8e3-fdad-4e4d-aa97-2593f699f930"],"size":0.776,"rotation":0,"height":666,"fitToCanvas":1,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/TS56SEsArBQguaz09KtscKI0zzx1/zeit_advise02.webp","translateX":-28,"translateY":0,"width":1000,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.13);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"breakpoints":[],"visible":true,"aspectRatio":1,"layerType":"effect","type":"mouse","animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0; const float kernel[24] = float[]( 0.7978845608028654, 0.795118932516684, 0.7868794322038799, 0.7733362336056986, 0.7547664553859864, 0.7315447328280048, 0.704130653528599, 0.6730536454899063, 0.6388960110447045, 0.6022748643096089, 0.5638237508206051, 0.5241747061566029, 0.48394144903828673, 0.443704309411472, 0.40399737110811773, 0.36529817077804383, 0.3280201493519873, 0.29250790855907144, 0.2590351913317835, 0.2278053882403838, 0.19895427758549736, 0.17255463765302306, 0.1486223271179862, 0.12712341303392466 );out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 blurTrail(vec2 uv, vec2 mouseDir) { vec2 distorted = mouseDir * 0.4; float total_weight = 0.0; vec4 color = vec4(0);for (int i = 0; i <= 24; i++) { float scale = 0.0001 + 0.47 * 0.5; float weight = kernel[i]; vec2 offset = distorted * (1.5 + scale) * mix(1.0, float(i) / ITERATIONS, scale); vec4 samp = texture(uTexture, uv - offset); samp.rgb = chromatic_aberration(samp.rgb, uv - offset, offset * 1.50 * 0.12); color += weight * samp; total_weight += weight; } return color / total_weight; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return blurTrail(uv, mouseDir); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.79 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st, float angle) { float aspectRatio = uResolution.x / uResolution.y; st.x *= aspectRatio; st = st * rot(angle * TWOPI); float amplitude = 0.003; for (float i = 1.0; i <= 5.0; i++) { st = st * rot(i / 5.0 * PI * 2.0); st += vec2( amplitude * cos(i * 5.0 * st.y + uTime * 0.02), amplitude * sin(i * 5.0 * st.x + uTime * 0.02) ); } st = st * rot(-angle * TWOPI); st.x /= aspectRatio; return st; }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.32 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;uv = mix(uv, liquify(uv, smoothstep(0.0, 1.0, angle)), 1.40);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.21, distanceToLine);vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec3 lastFrameColor = texture(uPingPongTexture, mix(uv, uv / 1.03 + 0.015, 0.60)).rgb; vec3 draw = mix(lastFrameColor, mouseColor, min(1.0, dist * s));fragColor = vec4(draw * pow(0.23, 0.1), 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{}}},{"breakpoints":[{"props":{"axis":{"type":"Vec3","_x":0.5,"_y":0.5,"_z":0.05},"refraction":1,"dispersion":0,"trackMouse":0,"shapeControl":1,"extrude":0.1,"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"twist":{"type":"Vec2","_x":0,"_y":0},"patternScale":0,"scale":0.314},"max":null,"name":"Desktop","min":992},{"props":{"shapeControl":1,"scale":0.25},"max":991,"name":"Tablet","min":576},{"props":{"scale":0.25},"max":575,"min":0,"name":"Mobile"}],"visible":true,"aspectRatio":1,"layerType":"effect","type":"sdf_shape","scale":0.314,"speed":0.5,"trackMouseMove":0,"mouseMomentum":0,"trackMouse":0,"parentLayer":"f91ec8e3-fdad-4e4d-aa97-2593f699f930","animating":true,"isMask":0,"states":{"appear":[{"type":"appear","id":"3fff621b-4f60-4add-968b-19d46e6cbc14","prop":"scale","transition":{"duration":1000,"ease":"easeInOutExpo","delay":1500},"complete":false,"progress":0,"initialStateSet":false,"value":0,"uniformData":{"type":"1f","name":"uScale"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; uniform sampler2D uTexture;uniform float uScale; uniform float uShapeControl; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.141592653; const float PI2 = 6.283185306; const float DISP_STEPS = 12.; const vec3 viewDir = vec3(0,0, -4.25);float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453); }mat3 rotY(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }mat3 rotX(float ang) { float c = cos(ang), s = sin(ang); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }mat3 rotZ(float ang) { float c = cos(ang), s = sin(ang); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }vec3 twistY(vec3 p, float amount) { float c = cos(amount * p.y); float s = sin(amount * p.y); mat2 m = mat2(c, -s, s, c); return vec3(m * p.xz, p.y); }vec3 twistX(vec3 p, float amount) { float c = cos(amount * p.x); float s = sin(amount * p.x); mat2 m = mat2(c, -s, s, c); return vec3(p.x, m * p.yz); }float opExtrusion(vec3 p, float d, float h) { vec2 w = vec2( d, abs(p.z) - h ); return min(max(w.x,w.y),0.0) + length(max(w,0.0)); }float sdStar5(vec2 p, float r, float rf) { const vec2 k1 = vec2(0.809016994375, -0.587785252292); const vec2 k2 = vec2(-k1.x,k1.y); p.x = abs(p.x); p -= 2.0*max(dot(k1,p),0.0)*k1; p -= 2.0*max(dot(k2,p),0.0)*k2; p.x = abs(p.x); p.y -= r; vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1); float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r ); return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y); }float sdRoundedBox( vec2 p, vec2 b, vec4 r ) { r.xy = (p.x>0.0)?r.xy : r.zw; r.x = (p.y>0.0)?r.x : r.y; vec2 q = abs(p)-b+r.x; return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x; }float squircle(vec3 p) { p *= rotY(radians(90.)); p *= rotX(radians(90.)); float d = sdRoundedBox(p.xy, vec2(0.75 + uShapeControl, 0.75 + (1.-uShapeControl)), vec4(0.33)); return opExtrusion(p, d, 0.10); }vec3 getRepeat(vec3 p) { float spacing = (0.50 + 0.01 * 0.38) * 8.; return p; }vec3 getThreeDRepeat(vec3 p) { float spacing = (0.50 + 0.01 * 0.38) * 8.; return p; }vec3 getAdjustedP(vec3 p) { vec3 adjustedP = p;vec2 twist = vec2(0, 0);adjustedP /= (uScale + 0.01);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.01 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.00); vec2 axis = vec2(-1. * vec3(0.5, 0.5, 0.05).y - 1. + mousePos.y/PI, vec3(0.5, 0.5, 0.05).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02; float timeX = vec3(0, 1, 0).x * baseTime; float timeY = vec3(0, 1, 0).y * baseTime; float timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI); mat3 rotXMat = rotX(axis.x * PI); mat3 rotZMat = rotZ(vec3(0.5, 0.5, 0.05).z * 2.0 * PI);mat3 animateYMat = rotY(timeY); mat3 animateXMat = rotX(timeX); mat3 animateZMat = rotZ(timeZ);mat3 combinedRotation = rotZMat * rotYMat * rotXMat; mat3 combinedAnimation = animateZMat * animateYMat * animateXMat;adjustedP = combinedRotation * adjustedP; adjustedP = combinedAnimation * adjustedP; adjustedP = getThreeDRepeat(adjustedP); adjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y))); adjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP; }float getMergedSDF(vec3 p) { p = getAdjustedP(p); return squircle(p); }float fresnel(vec3 eyeVector, vec3 worldNormal, float power) { float fresnelFactor = abs(dot(eyeVector, worldNormal)); float inversefresnelFactor = 1.0 - fresnelFactor; return pow(inversefresnelFactor, power); }vec3 noFrostOrDispersion(vec3 rd, vec3 normal) { float ior = 1.0 / (1.0 + 1.00 * 0.25); vec3 refractedRay = refract(rd, normal, ior); return texture(uTexture, vTextureCoord - refractedRay.xy).rgb; }vec3 calculateNormal(vec3 p, float eps) { float dx = getMergedSDF(p + vec3(eps, 0.0, 0.0)) - getMergedSDF(p - vec3(eps, 0.0, 0.0)); float dy = getMergedSDF(p + vec3(0.0, eps, 0.0)) - getMergedSDF(p - vec3(0.0, eps, 0.0)); float dz = getMergedSDF(p + vec3(0.0, 0.0, eps)) - getMergedSDF(p - vec3(0.0, 0.0, eps)); return normalize(vec3(dx, dy, dz)); }vec3 sampleTexture(vec3 rd, vec3 normal) { return noFrostOrDispersion(rd, normal); }float scene(vec3 p) { return max(0., getMergedSDF(p) - 0.01) * (uScale + 0.01); }const int STEPS = 128; const float MAX_DISTANCE = 40.0;vec4 rayMarch(vec3 ro, vec3 rd, float min_dist) { float traveled = 0.; vec3 entryPoint = vec3(0.0); vec3 entryNormal = vec3(0.0); float partialAlpha = 0.0;for (int i = 0; i < STEPS; ++i) { vec3 currentPos = ro + rd * traveled; float distance = scene(currentPos); if (distance < min_dist) { partialAlpha = 1.; entryPoint = currentPos; entryNormal = calculateNormal(entryPoint, min_dist); break; }if(traveled < 0.05) { traveled += distance * 0.9; } else { traveled += distance; } if (traveled > MAX_DISTANCE) break; }if (partialAlpha == 0.0) { return vec4(0); }vec4 bg = texture(uTexture, vTextureCoord);vec3 samplePosition = mix(rd, entryPoint, 0.00); vec3 refractionColor = sampleTexture(samplePosition, entryNormal);vec3 lightDir = vec3(((vec2(vec2(0.25, 0.25).x, 1.-vec2(0.25, 0.25).y) - 0.333) * 3.) - vec2(0.5, 0.5), -3.0); vec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir); vec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.00); vec3 fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.50 * vec3(1, 1, 1); vec3 halfwayDir = normalize(lightDir + rd); float specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.50 + 0.01); vec3 specularEffect = specFactor * 0.50 * lightColor; vec3 combinedEffects = fresnelEffect + specularEffect; vec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.00); finalColor += combinedEffects; vec4 outputColor = mix(bg, vec4(finalColor, 1.), partialAlpha);return outputColor; }out vec4 fragColor;void main() { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 uv = vTextureCoord - pos; float fovFactor = tan(radians(20.) * 0.5); vec3 rd = vec3(uv * fovFactor, 0.5);float mdist = 0.004; vec4 col = rayMarch(viewDir, rd, mdist); float dither = (rand(vTextureCoord.xy) - 0.5) / 255.0; col += dither; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"shapeControl":{"name":"uShapeControl","type":"1f","value":0.5},"scale":{"name":"uScale","type":"1f","value":0.5}}}}],"options":{"name":"Justlaunched_02","fps":60,"dpi":1.5,"scale":1,"includeLogo":true,"isProduction":false,"version":"1.3.1"},"version":"1.3.1"}